const fs = require('fs');
const path = require('path');

function isoDateString(d) {
  return d.toISOString().split('T')[0];
}

function ensureDir(dir) {
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

function parseFrontMatter(content) {
  const fmMatch = content.match(/^---\s*([\s\S]*?)\s*---/);
  if (!fmMatch) return {};
  const body = fmMatch[1];
  const result = {};
  // Very small front-matter parser for the keys we use (title, date, tags, status)
  const lines = body.split(/\r?\n/);
  let currentKey = null;
  for (let line of lines) {
    const kv = line.match(/^([A-Za-z0-9_-]+):\s*(.*)$/);
    if (kv) {
      currentKey = kv[1].trim();
      let val = kv[2].trim();
      if (val === '') {
        // maybe a list follows
        result[currentKey] = [];
      } else if (val.startsWith('[') && val.endsWith(']')) {
        // inline list: [a, b]
        const items = val.slice(1, -1).split(',').map(s => s.trim()).filter(Boolean);
        result[currentKey] = items;
      } else {
        result[currentKey] = val.replace(/^"(.*)"$/, '$1').replace(/^'(.*)'$/, '$1');
      }
    } else {
      // list item?
      const li = line.match(/^\s*-\s*(.*)$/);
      if (li && currentKey) {
        if (!Array.isArray(result[currentKey])) result[currentKey] = [];
        result[currentKey].push(li[1].trim());
      }
    }
  }
  return result;
}

function readPosts(postsDir) {
  if (!fs.existsSync(postsDir)) return [];
  const files = fs.readdirSync(postsDir).filter(f => f.endsWith('.md'));
  const entries = [];
  for (const f of files) {
    const full = path.join(postsDir, f);
    const raw = fs.readFileSync(full, 'utf8');
    const fm = parseFrontMatter(raw);
    // try to get date from frontmatter or filename (YYYY-MM-DD)
    let dateStr = fm.date || (f.match(/^(\d{4}-\d{2}-\d{2})/) || [])[1];
    if (!dateStr) {
      // try to find a date line somewhere
      const dateMatch = raw.match(/date:\s*([0-9]{4}-[0-9]{2}-[0-9]{2})/);
      if (dateMatch) dateStr = dateMatch[1];
    }
    const title = fm.title || f.replace(/\.md$/, '');
    const tags = fm.tags || [];
    const status = fm.status || '';
    entries.push({ file: f, path: full, date: dateStr, title, tags, status });
  }
  return entries;
}

function inRange(dateStr, start, end) {
  if (!dateStr) return false;
  const d = new Date(dateStr + 'T00:00:00Z');
  return d >= start && d <= end;
}

function formatDate(d) {
  return isoDateString(d);
}

function mondayOfCurrentWeek(today) {
  // Monday as start of week. getUTCDay: Sunday=0, Monday=1, ...
  const day = today.getUTCDay();
  const diff = (day + 6) % 7; // days since Monday
  const monday = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate()));
  monday.setUTCDate(monday.getUTCDate() - diff);
  return monday;
}

function main() {
  const postsDir = path.join(process.cwd(), 'posts');
  const summariesDir = path.join(process.cwd(), 'summaries');
  ensureDir(summariesDir);

  const today = new Date();
  const currentMonday = mondayOfCurrentWeek(today);
  // summary for previous week: start = currentMonday - 7 days, end = currentMonday - 1 day
  const start = new Date(currentMonday);
  start.setUTCDate(start.getUTCDate() - 7);
  const end = new Date(currentMonday);
  end.setUTCDate(end.getUTCDate() - 1);

  const entries = readPosts(postsDir).filter(e => inRange(e.date, start, end));
  // sort by date ascending
  entries.sort((a, b) => (a.date || '').localeCompare(b.date || ''));

  const tagCounts = {};
  for (const e of entries) {
    if (Array.isArray(e.tags)) {
      for (const t of e.tags) {
        tagCounts[t] = (tagCounts[t] || 0) + 1;
      }
    }
  }

  const outName = `${formatDate(start)}_to_${formatDate(end)}.md`;
  const outPath = path.join(summariesDir, outName);

  const lines = [];
  lines.push('---');
  lines.push(`title: "Weekly Summary: ${formatDate(start)} to ${formatDate(end)}"`);
  lines.push(`date: ${formatDate(today)}`);
  lines.push('tags: [summary, weekly]');
  lines.push('---');
  lines.push('');
  lines.push(`# Weekly Summary: ${formatDate(start)} — ${formatDate(end)}`);
  lines.push('');
  lines.push(`Generated: ${new Date().toISOString()}`);
  lines.push('');
  lines.push(`Total entries: ${entries.length}`);
  lines.push('');

  if (Object.keys(tagCounts).length > 0) {
    lines.push('Tags:');
    for (const [tag, count] of Object.entries(tagCounts).sort((a,b)=>b[1]-a[1])) {
      lines.push(`- ${tag} (${count})`);
    }
    lines.push('');
  }

  if (entries.length === 0) {
    lines.push('_No entries found for this week._');
  } else {
    lines.push('Entries:');
    for (const e of entries) {
      const entryRel = path.posix.join('posts', e.file);
      const tagsText = (Array.isArray(e.tags) && e.tags.length) ? ` — tags: ${e.tags.join(', ')}` : '';
      const statusText = e.status ? ` — ${e.status}` : '';
      lines.push(`- [${e.date} — ${e.title}](${entryRel})${tagsText}${statusText}`);
    }
  }

  lines.push('');
  lines.push('---');
  lines.push('_This file was auto-generated by .github/scripts/generate-weekly-summary.js_');

  fs.writeFileSync(outPath, lines.join('\n'), 'utf8');
  console.log(`Wrote summary: ${outPath}`);
}

main();
